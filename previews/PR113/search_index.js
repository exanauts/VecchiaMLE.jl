var documenterSearchIndex = {"docs":
[{"location":"api/#VecchiaMLE-Defines","page":"API","title":"VecchiaMLE Defines","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VecchiaMLE.ARCHITECTURES\nVecchiaMLE.PRINT_LEVEL\nVecchiaMLE.SPARSITY_GEN\nVecchiaMLE.SUPPORTED_SOLVERS\nVecchiaMLE.VecchiaCache\nVecchiaMLE.Diagnostics\nVecchiaMLE.VecchiaModel\nVecchiaMLE.VecchiaMLEInput","category":"page"},{"location":"api/#VecchiaMLE.ARCHITECTURES","page":"API","title":"VecchiaMLE.ARCHITECTURES","text":"Computer architecture on which the analysis will be run. Currently only defined as cpu or gpu, but in the future could encompass different gpu architectures. \n\nSupported Architectures\n\ncpu (:cpu) : CPU mode. \ngpu (:gpu) : GPU mode. Currently only CUDA is supported. \n\n\n\n\n\n","category":"constant"},{"location":"api/#VecchiaMLE.PRINT_LEVEL","page":"API","title":"VecchiaMLE.PRINT_LEVEL","text":"Print level of the program. Describes the verbosity of the package. Currently only implemented at the solver level.\n\nSupported Print Levels\n\nTRACE (:VTRACE) : Most Verbose.\nDEBUG (:VDEBUG) : Only useful for debugging.\nINFO  (:VINFO)  : Reports minor discrepancies in the code.\nWARN  (:VWARN)  : Reports major discrepancies in the code.\nERROR (:VERROR) : Reports errors that prevent normal execution.\nFATAL (:VFATAL) : Catastrophic failure. \n\n\n\n\n\n","category":"constant"},{"location":"api/#VecchiaMLE.SPARSITY_GEN","page":"API","title":"VecchiaMLE.SPARSITY_GEN","text":"Specification for the Sparsity Pattern generation algorithm. \n\nSupported Sparsity Patterns\n\nNearestNeighbors (:NN) : Based on https://github.com/KristofferC/NearestNeighbors.jl\nHNSW (:HNSW) : Based on https://github.com/JuliaNeighbors/HNSW.jl\nCustom (:USERGIVEN) : Given by user. You don't need to fill this field out, but the given sparsity pattern must be in CSC format. \n\n\n\n\n\n","category":"constant"},{"location":"api/#VecchiaMLE.SUPPORTED_SOLVERS","page":"API","title":"VecchiaMLE.SUPPORTED_SOLVERS","text":"Supported solvers for the optimization problem.\n\nSupported solvers\n\nMadNLP (:madnlp) : https://github.com/MadNLP/MadNLP.jl\nIpopt  (:ipopt)  : https://github.com/jump-dev/Ipopt.jl \nKNITRO (:knitro) : https://github.com/jump-dev/KNITRO.jl\n\n\n\n\n\n","category":"constant"},{"location":"api/#VecchiaMLE.VecchiaCache","page":"API","title":"VecchiaMLE.VecchiaCache","text":"Internal struct from which to fetch persisting objects in the optimization function. There is no need for a user to mess with this!\n\nFields\n\nn : Size of the problem\nM : Number of Samples\nnnzL : Number of nonzeros in L\ncolptrL : Array which indexes the beginning of each column in L\nrowsL : Row index of nonzero entries in L\ndiagL : Position of the diagonal coefficient of L\nm : Number of nonzeros in each column of L\noffsets : Number of nonzeros in hessobjvals before the block Bⱼ\nB : Vector of matrices Bⱼ, the constant blocks in the Hessian\nnnzh_tri_obj : Number of nonzeros in the lower triangular part of the Hessian of the objective\nnnzh_tri_lag : Number of nonzeros in the lower triangular part of the Hessian of the Lagrangian\nhess_obj_vals : Nonzeros of the lower triangular part of the Hessian of the objective\nbuffer : Additional buffer needed for the objective\n\n\n\n\n\n","category":"type"},{"location":"api/#VecchiaMLE.Diagnostics","page":"API","title":"VecchiaMLE.Diagnostics","text":"The Diagnostics struct that records some internals of the program that would be otherwise difficult to recover. The fields to the struct are as follows:\n\ncreate_model_time: Time taken to create Vecchia Cache and solver init.              \nlinalg_solve_time: Time in LinearAlgebra routines in solver.\nsolve_model_time: Time taken to solve model in solver.\nobjective_value: Optimal Objective value. \nnormed_constraint_value: Optimal norm of constraint vector.\nnormed_grad_value: Optimal norm of gradient vector.\niterations: Iterations for solver to reach optimal.\narch: Architecture. See ARCHITECTURES. \n\n\n\n\n\n","category":"type"},{"location":"api/#VecchiaMLE.VecchiaModel","page":"API","title":"VecchiaMLE.VecchiaModel","text":"Struct needed for NLPModels.  There is no need for the user to mess with this!\n\n\n\n\n\n","category":"type"},{"location":"api/#VecchiaMLE.VecchiaMLEInput","page":"API","title":"VecchiaMLE.VecchiaMLEInput","text":"Input to the VecchiaMLE analysis.\n\nFields\n\nk::Int: Number of neighbors, representing the number of conditioning points in the Vecchia Approximation.\nsamples::M: Samples to generate the output. Each sample should match the length of the observed_pts vector.\nplevel::Symbol: Print level for the optimizer. See PRINT_LEVEL. Defaults to :VERROR.\narch::Symbol: Architecture for the analysis. See ARCHITECTURES. Defaults to :cpu.\n\nKeyword Arguments\n\nplevel::Symbol            # Print level for the optimizer. See PRINT_LEVEL. Defaults to ERROR.\narch::Symbol              # Architecture for the analysis. See ARCHITECTURES. Defaults to :cpu.\nptset::AbstractVector     # The locations of the analysis. May be passed as a matrix or vector of vectors.\nlvar_diag::AbstractVector # Lower bounds on the diagonal of the sparse Vecchia approximation.\nuvar_diag::AbstractVector # Upper bounds on the diagonal of the sparse Vecchia approximation.\ncolptrL::AbstractVector   # The column pointer of L if the user gives one. MUST BE IN CSC FORMAT!\nsolver::Symbol            # Optimization solver (:madnlp, :ipopt, :knitro). Defaults to :madnlp.\nsolver_tol::Float64       # Tolerance for the optimization solver. Defaults to 1e-8.\nskipcheck::Bool          # Whether or not to skip the `validateinput` function.\nsparsityGeneration        # The method by which to generate a sparsity pattern. See SPARSITY_GEN.\nmetric::Distances.metric  # The metric by which nearest neighbors are determined. Defaults to Euclidean.\nlambda::Real              # The regularization scalar for the ridge 0.5 * λ‖L - diag(L)‖² in the objective. Defaults to 0.\nx0::AbstractVector        # The user may give an initial condition, but it is limiting if you do not have the sparsity pattern. \n\n\n\n\n\n","category":"type"},{"location":"api/#VecchiaMLE-input","page":"API","title":"VecchiaMLE input","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VecchiaMLE.VecchiaMLE_Run\nVecchiaMLE.VecchiaMLERunAnalysis!\nVecchiaMLE.ExecuteModel!\nVecchiaMLE.RetrieveDiagnostics!","category":"page"},{"location":"api/#VecchiaMLE.VecchiaMLE_Run","page":"API","title":"VecchiaMLE.VecchiaMLE_Run","text":"diagnostics, result = VecchiaMLE_Run(iVecchiaMLE::VecchiaMLEInput)\n\nMain function to run the analysis. Make sure that your VecchiaMLEInput struct is \nfilled out correctly!\n\nInput arguments\n\niVecchiaMLE: The filled out VecchiaMLEInput struct. See VecchiaMLEInput struct for more details.\n\nOutput arguments\n\ndiagnostics: Some diagnostics of the analysis that would be difficult otherwise to get. See Diagnostics struct for more details.\npreschol: The approximate precision's cholesky, generated by the samples. \n\n\n\n\n\n","category":"function"},{"location":"api/#VecchiaMLE.VecchiaMLERunAnalysis!","page":"API","title":"VecchiaMLE.VecchiaMLERunAnalysis!","text":"See VecchiaMLE_Run().\n\n\n\n\n\n","category":"function"},{"location":"api/#VecchiaMLE.ExecuteModel!","page":"API","title":"VecchiaMLE.ExecuteModel!","text":"See VecchiaMLE_Run().\n\n\n\n\n\n","category":"function"},{"location":"api/#VecchiaMLE.RetrieveDiagnostics!","page":"API","title":"VecchiaMLE.RetrieveDiagnostics!","text":"See VecchiaMLE_Run()\n\n\n\n\n\n","category":"function"},{"location":"api/#VecchiaMLE-utils","page":"API","title":"VecchiaMLE utils","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VecchiaMLE.generate_samples\nVecchiaMLE.generate_MatCov\nVecchiaMLE.generate_xyGrid\nVecchiaMLE.generate_safe_xyGrid\nVecchiaMLE.generate_rectGrid\nVecchiaMLE.print_diagnostics","category":"page"},{"location":"api/#VecchiaMLE.generate_samples","page":"API","title":"VecchiaMLE.generate_samples","text":"Samples_Matrix = generate_samples(MatCov::AbstractMatrix, \n                                  number_of_samples::Int;\n                                  arch::Symbol)\n\nGenerate a number of samples according to the given Covariance Matrix MatCov.\nNote the samples are given as mean zero.\n\nInput arguments\n\nMatCov: A Covariance Matrix, assumed positive definite;\nn: The length of one side of the Covariance matrix;\nnumber_of_samples: How many samples to return.\n\nKeyword Arguments\n\narch: Either to perform the linear algebra on cpu or gpu. See ARCHITECTURES. Defaults to :cpu.\n\nOutput arguments\n\nSamples_Matrix : A matrix of size (numberofsamples × n), where the rows are the i.i.d samples  \n\n\n\n\n\n","category":"function"},{"location":"api/#VecchiaMLE.generate_MatCov","page":"API","title":"VecchiaMLE.generate_MatCov","text":"Covariance_Matrix = generate_MatCov(params::AbstractArray,\n                                    ptset::AbstractVector)\n\nGenerates a matern-like Covariance Matrix determined via the given paramters (params) and ptset. \nSee https://en.wikipedia.org/wiki/Mat%C3%A9rn_covariance_function.\n\nInput arguments\n\nparams: An array of length 3 that holds the parameters to the matern covariance kernel (σ, ρ, ν);\nptset: A set of points in 2D space upon which we determine the indices of the Covariance matrix;\n\nOutput arguments\n\nCovariance_Matrix : An n × n Symmetric Matern matrix, where n = length(ptset).\n\n\n\n\n\nCovariance_Matrix = generate_MatCov(n::Int, \n                                    params::AbstractArray)\n\nGenerates a 2D matern-like Covariance Matrix determined via the given paramters (params). \nA square grid with `n` elements will be generated and used in lieu of a given location set.\nSee https://en.wikipedia.org/wiki/Mat%C3%A9rn_covariance_function.\n\nInput arguments\n\nn: The dimension of the desired MatCov;\nparams: An array of length 3 that holds the parameters to the matern covariance kernel (σ, ρ, ν);\n\nOutput arguments\n\nCovariance_Matrix : An n × n Symmetric Matern matrix \n\n\n\n\n\nCovariance_Matrix = generate_MatCov(params::AbstractArray,\n                                    ptset::AbstractMatrix)\n\nGenerates a matern-like Covariance Matrix determined via the given paramters (params). \nThe matrix of locations will be parsed as a vector of vectors, where each location is a row vector. \nSee https://en.wikipedia.org/wiki/Mat%C3%A9rn_covariance_function.\n\nInput arguments\n\nparams: An array of length 3 that holds the parameters to the matern covariance kernel (σ, ρ, ν);\nptset : A matrix filled with row vectors of locations. \n\nOutput arguments\n\nCovariance_Matrix : An n × n Symmetric Matern matrix, where n = size(ptset, 1).\n\n\n\n\n\n","category":"function"},{"location":"api/#VecchiaMLE.generate_xyGrid","page":"API","title":"VecchiaMLE.generate_xyGrid","text":"xyGrid = generate_xyGrid(n::Int)\n\nA helper function to generate a point grid which partitions the positive unit square [0, 1] × [0, 1].\nNOTE: This function at larger n values (n > 100) causes ill conditioning of the genreated Covariance matrix!\nSee generate_safe_xyGrid() for higher n values.\n\nInput arguments\n\nn: The length of the desired xyGrid;\n\nOutput arguments\n\nxyGrid : The desired points in 2D space  \n\n\n\n\n\n","category":"function"},{"location":"api/#VecchiaMLE.generate_safe_xyGrid","page":"API","title":"VecchiaMLE.generate_safe_xyGrid","text":"xyGrid = generate_safe_xyGrid(n::Int)\n\nA helper function to generate a point grid which partitions the positive square [0, k] × [0, k], \nwhere k = cld(n, 10). This should avoid ill conditioning of a Covariance Matrix generated by these points.\n\nInput arguments\n\nn: The length of the desired xyGrid;\n\nOutput arguments\n\nxyGrid : The desired points in 2D space  \n\n\n\n\n\n","category":"function"},{"location":"api/#VecchiaMLE.generate_rectGrid","page":"API","title":"VecchiaMLE.generate_rectGrid","text":"rect = generate_rectGrid(dims::Tuple)\n\nA helper function to generate a point grid which partitions the positive square [0, 1] × [0, 1] by dims[1] and dims[2]. \n\nInput arguments\n\ndims: A tuple of dimensions (nx, ny);\n\nOutput arguments\n\nrectGrid : The desired points in 2D space as a vector of 2-element arrays\n\n\n\n\n\n","category":"function"},{"location":"api/#VecchiaMLE.print_diagnostics","page":"API","title":"VecchiaMLE.print_diagnostics","text":"print_diagnostics(d::Diagnostics)\n\nPretty prints the diagnostics of the VecchiaMLE Algorithm.\n\nInput arguments\n\nd: The Diagnostics returned by the VecchiaMLERun function, assuming skipcheck wasn't set to true.\n\n\n\n\n\n","category":"function"},{"location":"api/#VecchiaMLE-internals","page":"API","title":"VecchiaMLE internals","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VecchiaMLE.get_vecchia_model \nVecchiaMLE.validate_input\nVecchiaMLE.nn_to_csc","category":"page"},{"location":"api/#VecchiaMLE.get_vecchia_model","page":"API","title":"VecchiaMLE.get_vecchia_model","text":"model = get_vecchia_model(iVecchiaMLE::VecchiaMLEInput)\n\nCreates and returns a vecchia model based on the VecchiaMLEInput and point grid.\n\nInput arguments\n\niVecchiaMLE: The filled out VecchiaMLEInput struct\n\nOutput arguments\n\nmodel: The Vecchia model based on the VecchiaMLEInput  \n\n\n\n\n\n","category":"function"},{"location":"api/#VecchiaMLE.validate_input","page":"API","title":"VecchiaMLE.validate_input","text":"validate_input(iVecchiaMLE::VecchiaMLEInput)\n\nA helper function to catch any inconsistencies in the input given by the user.\n\nInput arguments\n\niVecchiaMLE: The filled-out VecchiaMLEInput struct. See VecchiaMLEInput struct for more details. \n\n\n\n\n\n","category":"function"},{"location":"api/#VecchiaMLE.nn_to_csc","page":"API","title":"VecchiaMLE.nn_to_csc","text":"rows, colptr = nn_to_csc(sparmat::Matrix{Float64})\n\nA helper function to generate the sparsity pattern of the vecchia approximation (inverse cholesky) based \non each point's nearest neighbors. If there are n points, each with k nearest neighbors, then the matrix\nsparmat should be of size n x k. \n\nNOTE: The Nearest Neighbors algorithm should only consider points which appear before the given point. If\nyou do standard nearest neighbors and hack off the indices greater than the row number, it will not work. \n\nTODO: Can be parallelized. GPU kernel?\n\nInput arguments\n\nsparmat: The n x k matrix which for each row holds the indices of the nearest neighbors in the ptset.\n\nOutput arguments\n\nrows: A vector of row indices of the sparsity pattern for L, in CSC format.\ncolptr: A vector of incides which determine where new columns start. \n\n\n\n\n\n","category":"function"},{"location":"api/#VecchiaMLE-permutations","page":"API","title":"VecchiaMLE permutations","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VecchiaMLE.IndexReorder\nVecchiaMLE.IndexMaxMin\nVecchiaMLE.dist_from_set\nVecchiaMLE.IndexRandom","category":"page"},{"location":"api/#VecchiaMLE.IndexReorder","page":"API","title":"VecchiaMLE.IndexReorder","text":"permutation, dists = IndexReorder(condset::AbstractVector,\n                                   data::AbstractVector,\n                                   mu::AbstractVector,\n                                   method::String = \"standard\", \n                                   reverse_ordering::Bool = true)\n\nFront End function to determine the reordering of the given indices (data).\nAt the moment, only random, and maxmin are implemented.    \n\nI BELIEVE the intention is to permute the coordinates of the samples with it, e.g.,\nsamples = samples[:, permutation]. Note for small conditioning sets per point (extremely sparse L),\nthis is not worth while!.\n\nInput arguments\n\ncondset: A set of points from which to neglect from the index permutation;\ndata: The data to determine said permutation;\nmu: The theoretical mean of the data, not mean(data)!\nmethod: Either permuting based on maxmin, or random.\nreverse_ordering: permutation is generated either in reverse or not.   \n\nOutput arguments\n\npermutation: The index set which permutes the given data.\ndists: The array of maximum distances to iterating conditioning sets.    \n\n\n\n\n\n","category":"function"},{"location":"api/#VecchiaMLE.IndexMaxMin","page":"API","title":"VecchiaMLE.IndexMaxMin","text":"See IndexReorder().\n\n\n\n\n\n","category":"function"},{"location":"api/#VecchiaMLE.dist_from_set","page":"API","title":"VecchiaMLE.dist_from_set","text":"Helper function. See IndexReorder().\n\n\n\n\n\n","category":"function"},{"location":"api/#VecchiaMLE.IndexRandom","page":"API","title":"VecchiaMLE.IndexRandom","text":"See IndexReorder().\n\n\n\n\n\n","category":"function"},{"location":"api/#VecchiaMLE-sparsitypatterns","page":"API","title":"VecchiaMLE sparsitypatterns","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VecchiaMLE.sparsitypattern\nVecchiaMLE.sparsitypattern_HNSW\nVecchiaMLE.sparsitypattern_NN","category":"page"},{"location":"api/#VecchiaMLE.sparsitypattern","page":"API","title":"VecchiaMLE.sparsitypattern","text":"rows, colptr = sparsitypattern(\n    ::Val{<:Symbol}, \n    data::AbstractVector,\n    k::Int,\n    metric::Distances.Metric=Distances.Euclidean()\n)\n\nGenerates the sparsity pattern of the approximate \nprecision's cholesky factor, L, in CSC format. The pattern is \ndetermined by nearest neighbors of the previous points in data.\n\nInput arguments\n\ndata: The point grid that was used to either generate the covariance matrix, or any custom ptset.\nk: The number of nearest neighbors for each point (Including the point itself)\nmethod: How the sparsity pattern is generated. See SPARSITY_GEN\nmetric: The metric for determining nearest neighbors.\n\nOutput arguments\n\nrows: A vector of row indices of the sparsity pattern for L, in CSC format.\ncolptr: A vector of incides which determine where new columns start. \n\n\n\n\n\n","category":"function"},{"location":"api/#VecchiaMLE.sparsitypattern_HNSW","page":"API","title":"VecchiaMLE.sparsitypattern_HNSW","text":"See sparsitypattern(). In place for HNSW.jl\n\n\n\n\n\n","category":"function"},{"location":"api/#VecchiaMLE.sparsitypattern_NN","page":"API","title":"VecchiaMLE.sparsitypattern_NN","text":"See sparsitypattern(). Uses NearestNeighbors library. In case of tie, opt for larger index. \n\n\n\n\n\n","category":"function"},{"location":"api/#VecchiaMLE-errors","page":"API","title":"VecchiaMLE errors","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VecchiaMLE.uni_error\nVecchiaMLE.KLDivergence","category":"page"},{"location":"api/#VecchiaMLE.uni_error","page":"API","title":"VecchiaMLE.uni_error","text":"Error = uni_error(TCov::AbstractMatrix,\n                  L::AbstractMatrix)\nGenerates the \"Univariate KL Divergence\" from the Given True Covariane matrix \nand Approximate Covariance matrix. The output is the result of the following \noptimization problem: sup(a^T X_A || a^⊺ X_T). The solution is \n            f(μ) = ln(μ) + (2μ)^{-2} - 0.5,\nwhere μ is the largest or smallest eigenvalue of the matrix Σ_A^{-1}Σ_T, whichever\nmaximizes the function f(μ). Note: Σ_A , Σ_T are the respective approximate and true\ncovariance matrices, and X_A, X_T are samples from the respective Distributions (mean zero).\n\nInput arguments\n\nTCov: The True Covariance Matrix: the one we are approximating;\nL: The cholesky factor of the approximate precision matrix.\n\nOutput arguments\n\nf(μ) : the result of the function f(μ) detailed above.   \n\n\n\n\n\n","category":"function"},{"location":"api/#VecchiaMLE.KLDivergence","page":"API","title":"VecchiaMLE.KLDivergence","text":"KL_Divergence = KLDivergence(TCov::Symmetric{Float64},\n                             AL::AbstractMatrix)\n\nComputes the KL Divergence of the True Covariance matrix, TCov, and\nThe APPROXIMATE INVERSE CHOLESKY FACTOR, AL. Assumed mean zero.\nNote: This is extremely slow!\n\nInput arguments\n\nTCov: The True Covariance Matrix;\nAL: The cholesky factor to the approximate precision matrix. I.e., The ouptut of VecchiaMLE.  \n\nOutput arguments\n\nKL_Divergence: The result of the KL Divergence function.\n\n\n\n\n\nKL_Divergence = KLDivergence(TChol::T, AChol::T) where {T <: AbstractMatrix}\n\nComputes the KL Divergence of the cholesky of the True Covariance matrix, TChol, and The APPROXIMATE INVERSE CHOLESKY FACTOR (The output of VecchiaMLE), AChol. Assumed mean zero.\n\nInput arguments\n\nTChol: The cholesky of the True Covariance Matrix;\nAChol: The cholesky factor to the approximate precision matrix. I.e., The ouptut of VecchiaMLE.  \n\nOutput arguments\n\nKL_Divergence: The result of the KL Divergence function.\n\n\n\n\n\n","category":"function"},{"location":"examples/IterativeSolves/#Running-VecchiaMLE-for-Multiple-Iterations","page":"Running VecchiaMLE for Multiple Iterations","title":"Running VecchiaMLE for Multiple Iterations","text":"","category":"section"},{"location":"examples/IterativeSolves/","page":"Running VecchiaMLE for Multiple Iterations","title":"Running VecchiaMLE for Multiple Iterations","text":"Let's say there is some analysis which requires the inverse cholesky of a Covariance matrix for each iteration.  Since VecchiaMLE can be decomposed into two separate processes (to find the sparsity pattern of L, and to recover its entries), and the set of locations does not change, we can skip the most computationally heavy part of VecchiaMLE. ","category":"page"},{"location":"examples/IterativeSolves/","page":"Running VecchiaMLE for Multiple Iterations","title":"Running VecchiaMLE for Multiple Iterations","text":"We generate a toy analysis to demonstrate this. ","category":"page"},{"location":"examples/IterativeSolves/","page":"Running VecchiaMLE for Multiple Iterations","title":"Running VecchiaMLE for Multiple Iterations","text":"using VecchiaMLE\nusing SparseArrays # To show matrix at the end \n\nn = 100\nk = 10\nnumber_of_samples = 100\nparams = [5.0, 0.2, 2.25]\nMatCov = VecchiaMLE.generate_MatCov(n, params)\nsamples = VecchiaMLE.generate_samples(MatCov, number_of_samples; arch=:cpu)\n\nniter = 5\n\nrowsL = ones(Int, Int(0.5 * k * (2*n - k + 1)))\ncolptrL = ones(Int, n+1)\n\nfor i in 1:niter\n    if i == 1\n        input = VecchiaMLEInput(k, samples)\n    else\n        input = VecchiaMLEInput(k, samples; rowsL=rowsL, colptrL=colptrL)\n    end\n\n    _, L = VecchiaMLE_Run(input)\n    println(\"Iter $(i) Error: \", VecchiaMLE.KLDivergence(MatCov, L))\n\n    # save sparsity pattern\n    if i == 1\n        global rowsL = L.rowval\n        global colptrL = L.colptr\n    end\nend","category":"page"},{"location":"examples/IterativeSolves/","page":"Running VecchiaMLE for Multiple Iterations","title":"Running VecchiaMLE for Multiple Iterations","text":"Since the ptset didn't change over iterations, we can assume the sparsity pattern doesn't change. Therefore,  we can save the sparsity pattern after the first iteration, and reuse it. This saves an enormous amount of time, from personal anecdote. ","category":"page"},{"location":"#Home","page":"Home","title":"VecchiaMLE.jl documentation","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package computes an approximate Cholesky factorization of a covariance matrix using a Maximum Likelihood Estimation (MLE) approach. The Cholesky factor is computed via the Vecchia approximation, which is sparse and approximately banded, making it highly efficient for large-scale problems.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> ]\npkg> add https://github.com/exanauts/VecchiaMLE.jl.git\npkg> test VecchiaMLE","category":"page"},{"location":"examples/HowToRun/#How-To-Reuse-the-Solution-of-VecchiaMLE","page":"Tutorials","title":"How To Reuse the Solution of VecchiaMLE","text":"","category":"section"},{"location":"examples/HowToRun/","page":"Tutorials","title":"Tutorials","text":"This example shows how to run VecchiaMLE for a given VecchiaMLEInput from absolute scratch. That is, we start with no samples, and no location set ptset. In this case, we define three parameters.","category":"page"},{"location":"examples/HowToRun/","page":"Tutorials","title":"Tutorials","text":"using VecchiaMLE\nusing SparseArrays # To show matrix at the end \n\n# Things for model\nn = 400                 # Dimension\nk = 10                  # Conditioning\nnumber_of_samples = 100 # Number of Samples to generate","category":"page"},{"location":"examples/HowToRun/","page":"Tutorials","title":"Tutorials","text":"These three parameters determine any given analysis. We rely on funcitons defined in  VecchiaMLE, namely those to generate samples.   ","category":"page"},{"location":"examples/HowToRun/","page":"Tutorials","title":"Tutorials","text":"The sample generation requires a covariance matrix. We generate a matern like covariance matrix for our analysis. We allow the generation of samples in the following manner:","category":"page"},{"location":"examples/HowToRun/","page":"Tutorials","title":"Tutorials","text":"params = [5.0, 0.2, 2.25, 0.25]\n# This analysis will be done in 2D.\nptset = VecchiaMLE.generate_safe_xyGrid(n)\nMatCov = VecchiaMLE.generate_MatCov(params, ptset)\nsamples = VecchiaMLE.generate_samples(MatCov, number_of_samples)","category":"page"},{"location":"examples/HowToRun/","page":"Tutorials","title":"Tutorials","text":"Above, we generate a set of locations (ptset), a covariance matrix (MatCov), and the samples.   Next, we create and fill in the VecchiaMLEInput struct. This is done below.","category":"page"},{"location":"examples/HowToRun/","page":"Tutorials","title":"Tutorials","text":"input = VecchiaMLE.VecchiaMLEInput(k, samples; ptset=ptset)","category":"page"},{"location":"examples/HowToRun/","page":"Tutorials","title":"Tutorials","text":"The constructor takes at the bare minimum the locations on which to condition any given point (k),  as well as the samples matrix. Since a ptset was already generated, we go ahead and provide this. If  a ptset is not given, we fall back on a default locations set defined by the function generate_safe_xyGrid. ","category":"page"},{"location":"examples/HowToRun/","page":"Tutorials","title":"Tutorials","text":"All that's left is to run the analysis. This is done in one line:","category":"page"},{"location":"examples/HowToRun/","page":"Tutorials","title":"Tutorials","text":"d, L = VecchiaMLE_Run(input)","category":"page"},{"location":"examples/HowToRun/","page":"Tutorials","title":"Tutorials","text":"We can see the structure of the output of the program has an approximately banded structure.  This is due to the underlying assumption of the Vecchia Approximation where locaitons are independent of  eachother when conditioned on its k nearest neighbors. ","category":"page"},{"location":"examples/HowToRun/","page":"Tutorials","title":"Tutorials","text":"sparse(L)","category":"page"},{"location":"examples/HowToRun/","page":"Tutorials","title":"Tutorials","text":"The function VecchiaMLE_Run returns a tuple, respectively containing the diagnostics of the solver, and the inverse cholesky factor L. A function to obtian the KL Divergence of this approximation, is provided via an internal function of VecchiaMLE.  ","category":"page"},{"location":"examples/HowToRun/","page":"Tutorials","title":"Tutorials","text":"println(\"Error: \", VecchiaMLE.KLDivergence(MatCov, L))","category":"page"},{"location":"examples/HowToRun/","page":"Tutorials","title":"Tutorials","text":"The diagnostics can be displayed via an internal function. ","category":"page"},{"location":"examples/HowToRun/","page":"Tutorials","title":"Tutorials","text":"VecchiaMLE.print_diagnostics(d)","category":"page"}]
}
