var documenterSearchIndex = {"docs":
[{"location":"api/#VecchiaMLE-defines","page":"API","title":"VecchiaMLE defines","text":"","category":"section"},{"location":"api/#VecchiaMLE-utils","page":"API","title":"VecchiaMLE utils","text":"","category":"section"},{"location":"api/#VecchiaMLE-internals","page":"API","title":"VecchiaMLE internals","text":"","category":"section"},{"location":"api/#VecchiaMLE-permutations","page":"API","title":"VecchiaMLE permutations","text":"","category":"section"},{"location":"api/#VecchiaMLE-sparsity-patterns","page":"API","title":"VecchiaMLE sparsity patterns","text":"","category":"section"},{"location":"api/#VecchiaMLE.SPARSITY_GEN","page":"API","title":"VecchiaMLE.SPARSITY_GEN","text":"Specification for the Sparsity Pattern generation algorithm. \n\nSupported Sparsity Patterns\n\nNearestNeighbors (:NN) : Based on https://github.com/KristofferC/NearestNeighbors.jl\nHNSW (:HNSW) : Based on https://github.com/JuliaNeighbors/HNSW.jl\nCustom (:USERGIVEN) : Given by user. You don't need to fill this field out, but the given sparsity pattern must be in CSC format. \n\n\n\n\n\n","category":"constant"},{"location":"api/#VecchiaMLE.VecchiaCache","page":"API","title":"VecchiaMLE.VecchiaCache","text":"Internal struct from which to fetch persisting objects in the optimization function. There is no need for a user to mess with this!\n\nFields\n\nn : Size of the problem\nM : Number of Samples\nnnzL : Number of nonzeros in L\ncolptrL : Array which indexes the beginning of each column in L\nrowsL : Row index of nonzero entries in L\ndiagL : Position of the diagonal coefficient of L\nm : Number of nonzeros in each column of L\noffsets : Number of nonzeros in hessobjvals before the block Bⱼ\nB : Vector of matrices Bⱼ, the constant blocks in the Hessian\nnnzh_tri_obj : Number of nonzeros in the lower triangular part of the Hessian of the objective\nnnzh_tri_lag : Number of nonzeros in the lower triangular part of the Hessian of the Lagrangian\nhess_obj_vals : Nonzeros of the lower triangular part of the Hessian of the objective\nbuffer : Additional buffer needed for the objective\n\n\n\n\n\n","category":"type"},{"location":"api/#VecchiaMLE.VecchiaModel","page":"API","title":"VecchiaMLE.VecchiaModel","text":"Struct needed for NLPModels.  There is no need for the user to mess with this!\n\n\n\n\n\n","category":"type"},{"location":"api/#VecchiaMLE.VecchiaMLEInput","page":"API","title":"VecchiaMLE.VecchiaMLEInput","text":"Input to the VecchiaMLE analysis.\n\nFields\n\nk::Int: Number of neighbors, representing the number of conditioning points in the Vecchia Approximation.\nsamples::M: Samples to generate the output. Each sample should match the length of the observed_pts vector.\n\nKeyword Arguments\n\nptset::AbstractVector     # The locations of the analysis. May be passed as a matrix or vector of vectors.\nrowsL::AbstractVector     # The sparsity pattern rows of L if the user gives one. MUST BE IN CSC FORMAT!\ncolptrL::AbstractVector   # The column pointer of L if the user gives one. MUST BE IN CSC FORMAT!\nmetric::Distances.metric  # The metric by which nearest neighbors are determined. Defaults to Euclidean.\nsparsitygen::Symbol       # The method by which to generate a sparsity pattern. See SPARSITY_GEN.\n\n\n\n\n\n","category":"type"},{"location":"api/#VecchiaMLE.generate_samples","page":"API","title":"VecchiaMLE.generate_samples","text":"Samples_Matrix = generate_samples(MatCov::AbstractMatrix, \n                                  number_of_samples::Int;\n                                  arch::Symbol)\n\nGenerate a number of samples according to the given Covariance Matrix MatCov.\nNote the samples are given as mean zero.\n\nInput arguments\n\nMatCov: A Covariance Matrix, assumed positive definite;\nn: The length of one side of the Covariance matrix;\nnumber_of_samples: How many samples to return.\n\nKeyword Arguments\n\narch: Either to perform the linear algebra on cpu or gpu. See ARCHITECTURES. Defaults to :cpu.\n\nOutput arguments\n\nSamples_Matrix : A matrix of size (numberofsamples × n), where the rows are the i.i.d samples  \n\n\n\n\n\n","category":"function"},{"location":"api/#VecchiaMLE.generate_MatCov","page":"API","title":"VecchiaMLE.generate_MatCov","text":"Covariance_Matrix = generate_MatCov(params::AbstractArray,\n                                    ptset::AbstractVector)\n\nGenerates a matern-like Covariance Matrix determined via the given paramters (params) and ptset. \nSee https://en.wikipedia.org/wiki/Mat%C3%A9rn_covariance_function.\n\nInput arguments\n\nparams: An array of length 3 that holds the parameters to the matern covariance kernel (σ, ρ, ν);\nptset: A set of points in 2D space upon which we determine the indices of the Covariance matrix;\n\nOutput arguments\n\nCovariance_Matrix : An n × n Symmetric Matern matrix, where n = length(ptset).\n\n\n\n\n\nCovariance_Matrix = generate_MatCov(n::Int, \n                                    params::AbstractArray)\n\nGenerates a 2D matern-like Covariance Matrix determined via the given paramters (params). \nA square grid with `n` elements will be generated and used in lieu of a given location set.\nSee https://en.wikipedia.org/wiki/Mat%C3%A9rn_covariance_function.\n\nInput arguments\n\nn: The dimension of the desired MatCov;\nparams: An array of length 3 that holds the parameters to the matern covariance kernel (σ, ρ, ν);\n\nOutput arguments\n\nCovariance_Matrix : An n × n Symmetric Matern matrix \n\n\n\n\n\nCovariance_Matrix = generate_MatCov(params::AbstractArray,\n                                    ptset::AbstractMatrix)\n\nGenerates a matern-like Covariance Matrix determined via the given paramters (params). \nThe matrix of locations will be parsed as a vector of vectors, where each location is a row vector. \nSee https://en.wikipedia.org/wiki/Mat%C3%A9rn_covariance_function.\n\nInput arguments\n\nparams: An array of length 3 that holds the parameters to the matern covariance kernel (σ, ρ, ν);\nptset : A matrix filled with row vectors of locations. \n\nOutput arguments\n\nCovariance_Matrix : An n × n Symmetric Matern matrix, where n = size(ptset, 1).\n\n\n\n\n\n","category":"function"},{"location":"api/#VecchiaMLE.generate_xyGrid","page":"API","title":"VecchiaMLE.generate_xyGrid","text":"xyGrid = generate_xyGrid(n::Int)\n\nA helper function to generate a point grid which partitions the positive unit square [0, 1] × [0, 1].\nNOTE: This function at larger n values (n > 100) causes ill conditioning of the genreated Covariance matrix!\nSee generate_safe_xyGrid() for higher n values.\n\nInput arguments\n\nn: The length of the desired xyGrid;\n\nOutput arguments\n\nxyGrid : The desired points in 2D space  \n\n\n\n\n\n","category":"function"},{"location":"api/#VecchiaMLE.generate_safe_xyGrid","page":"API","title":"VecchiaMLE.generate_safe_xyGrid","text":"xyGrid = generate_safe_xyGrid(n::Int)\n\nA helper function to generate a point grid which partitions the positive square [0, k] × [0, k], \nwhere k = cld(n, 10). This should avoid ill conditioning of a Covariance Matrix generated by these points.\n\nInput arguments\n\nn: The length of the desired xyGrid;\n\nOutput arguments\n\nxyGrid : The desired points in 2D space  \n\n\n\n\n\n","category":"function"},{"location":"api/#VecchiaMLE.generate_rectGrid","page":"API","title":"VecchiaMLE.generate_rectGrid","text":"rect = generate_rectGrid(dims::Tuple)\n\nA helper function to generate a point grid which partitions the positive square [0, 1] × [0, 1] by dims[1] and dims[2]. \n\nInput arguments\n\ndims: A tuple of dimensions (nx, ny);\n\nOutput arguments\n\nrectGrid : The desired points in 2D space as a vector of 2-element arrays\n\n\n\n\n\n","category":"function"},{"location":"api/#VecchiaMLE.nn_to_csc","page":"API","title":"VecchiaMLE.nn_to_csc","text":"rows, colptr = nn_to_csc(sparmat::Matrix{Float64})\n\nA helper function to generate the sparsity pattern of the vecchia approximation (inverse cholesky) based \non each point's nearest neighbors. If there are n points, each with k nearest neighbors, then the matrix\nsparmat should be of size n x k. \n\nNOTE: The Nearest Neighbors algorithm should only consider points which appear before the given point. If\nyou do standard nearest neighbors and hack off the indices greater than the row number, it will not work. \n\nTODO: Can be parallelized. GPU kernel?\n\nInput arguments\n\nsparmat: The n x k matrix which for each row holds the indices of the nearest neighbors in the ptset.\n\nOutput arguments\n\nrows: A vector of row indices of the sparsity pattern for L, in CSC format.\ncolptr: A vector of incides which determine where new columns start. \n\n\n\n\n\n","category":"function"},{"location":"api/#VecchiaMLE.IndexReorder","page":"API","title":"VecchiaMLE.IndexReorder","text":"permutation, dists = IndexReorder(condset::AbstractVector,\n                                   data::AbstractVector,\n                                   mu::AbstractVector,\n                                   method::String = \"standard\", \n                                   reverse_ordering::Bool = true)\n\nFront End function to determine the reordering of the given indices (data).\nAt the moment, only random, and maxmin are implemented.    \n\nI BELIEVE the intention is to permute the coordinates of the samples with it, e.g.,\nsamples = samples[:, permutation]. Note for small conditioning sets per point (extremely sparse L),\nthis is not worth while!.\n\nInput arguments\n\ncondset: A set of points from which to neglect from the index permutation;\ndata: The data to determine said permutation;\nmu: The theoretical mean of the data, not mean(data)!\nmethod: Either permuting based on maxmin, or random.\nreverse_ordering: permutation is generated either in reverse or not.   \n\nOutput arguments\n\npermutation: The index set which permutes the given data.\ndists: The array of maximum distances to iterating conditioning sets.    \n\n\n\n\n\n","category":"function"},{"location":"api/#VecchiaMLE.IndexMaxMin","page":"API","title":"VecchiaMLE.IndexMaxMin","text":"See IndexReorder().\n\n\n\n\n\n","category":"function"},{"location":"api/#VecchiaMLE.IndexRandom","page":"API","title":"VecchiaMLE.IndexRandom","text":"See IndexReorder().\n\n\n\n\n\n","category":"function"},{"location":"api/#VecchiaMLE.dist_from_set","page":"API","title":"VecchiaMLE.dist_from_set","text":"Helper function. See IndexReorder().\n\n\n\n\n\n","category":"function"},{"location":"api/#VecchiaMLE.sparsity_pattern","page":"API","title":"VecchiaMLE.sparsity_pattern","text":"rows, colptr = sparsity_pattern(\n    ::Val{<:Symbol}, \n    data::AbstractVector,\n    k::Int,\n    metric::Distances.Metric=Distances.Euclidean()\n)\n\nGenerates the sparsity pattern of the approximate \nprecision's cholesky factor, L, in CSC format. The pattern is \ndetermined by nearest neighbors of the previous points in data.\n\nInput arguments\n\ndata: The point grid that was used to either generate the covariance matrix, or any custom ptset.\nk: The number of nearest neighbors for each point (Including the point itself)\nmethod: How the sparsity pattern is generated. See SPARSITY_GEN\nmetric: The metric for determining nearest neighbors.\n\nOutput arguments\n\nrows: A vector of row indices of the sparsity pattern for L, in CSC format.\ncolptr: A vector of incides which determine where new columns start. \n\n\n\n\n\n","category":"function"},{"location":"api/#VecchiaMLE.sparsity_pattern_HNSW","page":"API","title":"VecchiaMLE.sparsity_pattern_HNSW","text":"See sparsity_pattern(). In place for HNSW.jl\n\n\n\n\n\n","category":"function"},{"location":"api/#VecchiaMLE.sparsity_pattern_NN","page":"API","title":"VecchiaMLE.sparsity_pattern_NN","text":"See sparsity_pattern(). Uses NearestNeighbors library. In case of tie, opt for larger index. \n\n\n\n\n\n","category":"function"},{"location":"how_to_run/#How-To-Reuse-the-Solution-of-VecchiaMLE","page":"Tutorials","title":"How To Reuse the Solution of VecchiaMLE","text":"This example shows how to run VecchiaMLE for a given VecchiaMLEInput from absolute scratch. That is, we start with no samples, and no location set ptset. In this case, we define three parameters.\n\nusing VecchiaMLE\nusing SparseArrays # To show matrix at the end \n\n# Things for model\nn = 400                 # Dimension\nk = 10                  # Conditioning\nnumber_of_samples = 100 # Number of Samples to generate\n\nThese three parameters determine any given analysis. We rely on funcitons defined in  VecchiaMLE, namely those to generate samples.   \n\nThe sample generation requires a covariance matrix. We generate a matern like covariance matrix for our analysis. We allow the generation of samples in the following manner:\n\nparams = [5.0, 0.2, 2.25, 0.25]\n# This analysis will be done in 2D.\nptset = VecchiaMLE.generate_safe_xyGrid(n)\nMatCov = VecchiaMLE.generate_MatCov(params, ptset)\nsamples = VecchiaMLE.generate_samples(MatCov, number_of_samples)\n\nAbove, we generate a set of locations (ptset), a covariance matrix (MatCov), and the samples.   Next, we create and fill in the VecchiaMLEInput struct. This is done below.\n\ninput = VecchiaMLE.VecchiaMLEInput(k, samples; ptset=ptset)\n\nThe constructor takes at the bare minimum the locations on which to condition any given point (k),  as well as the samples matrix. Since a ptset was already generated, we go ahead and provide this. If  a ptset is not given, we fall back on a default locations set defined by the function generate_safe_xyGrid. \n\nAll that's left is to run the analysis. This is done in one line:\n\nusing NLPModelsIpopt\n\nrowsL, colptrL = sparsity_pattern(input)\nmodel = VecchiaModel(rowsL, colptrL, samples; format=:csc, uplo=:L)\n\noutput = ipopt(model)\nL = recover_factor(model, output.solution)","category":"section"},{"location":"vecchia_model/","page":"Vecchia model","title":"Vecchia model","text":"using VecchiaMLE\nusing LinearAlgebra\nusing SparseArrays\nusing NLPModelsIpopt\n\nn = 400\nnumber_of_samples = 100\n\nparams = [5.0, 0.2, 2.25, 0.25]\nptset = VecchiaMLE.generate_safe_xyGrid(n)\nMatCov = generate_MatCov(params, ptset)\nsamples = generate_samples(MatCov, number_of_samples)\n\nP = ones(n, n)\nP = tril(P)\nP = sparse(P)\nI, J, V = findnz(P)\nnlp_L = VecchiaModel(I, J, samples; format=:coo, uplo=:L)\noutput = ipopt(nlp_L)\nL = recover_factor(nlp_L, output.solution)\n\nusing VecchiaMLE\nusing LinearAlgebra\nusing SparseArrays\nusing NLPModelsIpopt\n\nn = 400\nnumber_of_samples = 100\n\nparams = [5.0, 0.2, 2.25, 0.25]\nptset = VecchiaMLE.generate_safe_xyGrid(n)\nMatCov = generate_MatCov(params, ptset)\nsamples = generate_samples(MatCov, number_of_samples)\n\nP = ones(n, n)\nP = triu(P)\nP = sparse(P)\nI, J, V = findnz(P)\nnlp_U = VecchiaModel(I, J, samples; format=:coo, uplo=:U)\noutput = ipopt(nlp_U)\nU = recover_factor(nlp_U, output.solution)","category":"section"},{"location":"#Home","page":"Home","title":"VecchiaMLE.jl documentation","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"This package computes an approximate Cholesky factorization of a covariance matrix using a Maximum Likelihood Estimation (MLE) approach. The Cholesky factor is computed via the Vecchia approximation, which is sparse and approximately banded, making it highly efficient for large-scale problems.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"julia> ]\npkg> add https://github.com/exanauts/VecchiaMLE.jl.git\npkg> test VecchiaMLE","category":"section"}]
}
