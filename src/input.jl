"""
    diagnostics, result = VecchiaMLE_Run(iVecchiaMLE::VecchiaMLEInput)

    Main function to run the analysis. Make sure that your VecchiaMLEInput struct is 
    filled out correctly!

## Input arguments
* `iVecchiaMLE`: The filled out VecchiaMLEInput struct. See VecchiaMLEInput struct for more details.

## Output arguments
* `diagnostics`: Some diagnostics of the analysis that would be difficult otherwise to get. See Diagnostics struct for more details.
* `preschol`: The approximate precision's cholesky, generated by the samples. 
"""
function VecchiaMLE_Run(iVecchiaMLE::VecchiaMLEInput)

    !iVecchiaMLE.skip_check && validate_input(iVecchiaMLE)
    diagnostics = Diagnostics(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, :cpu)
    preschol = VecchiaMLERunAnalysis!(iVecchiaMLE, diagnostics)
    
    return diagnostics, preschol
end

"""
See VecchiaMLE_Run().
"""
function VecchiaMLERunAnalysis!(iVecchiaMLE::VecchiaMLEInput, diagnostics::Diagnostics)
    model, output, preschol = ExecuteModel!(iVecchiaMLE, diagnostics)
    
    !iVecchiaMLE.diagnostics && RetrieveDiagnostics!(iVecchiaMLE, output, model, diagnostics)
    return preschol
end

"""
See VecchiaMLE_Run().
"""
function ExecuteModel!(iVecchiaMLE::VecchiaMLEInput, diags::Diagnostics)
    diags.create_model_time = @elapsed begin
        model = get_vecchia_model(iVecchiaMLE)
    end
    
    diags.solve_model_time = @elapsed begin
        output = vecchia_solver(Val(iVecchiaMLE.solver), model,
            linear_solver = resolve_linear_solver(Val(iVecchiaMLE.solver), Val(iVecchiaMLE.linear_solver)),
            print_level=resolve_plevel(Val(iVecchiaMLE.solver), Val(iVecchiaMLE.plevel)),
            tol=iVecchiaMLE.solver_tol
        )
    end
    
    S = Vector{Int}
    preschol = SparseMatrixCSC(iVecchiaMLE.n, iVecchiaMLE.n, 
        S(iVecchiaMLE.colptrL), S(iVecchiaMLE.rowsL),
        Vector{Float64}(view(output.solution, 1:model.cache.nnzL))
    )


    return model, output, preschol
end

"""
See VecchiaMLE_Run()
"""
function RetrieveDiagnostics!(iVecchiaMLE, output, model, diagnostics)
    if iVecchiaMLE.solver == :madnlp
        diagnostics.linalg_solve_time = output.counters.linear_solver_time
    end
    diagnostics.iterations = output.iter
    diagnostics.arch = iVecchiaMLE.arch

    # Getting some values for error checking
    diagnostics.objective_value = NLPModels.obj(model, output.solution)
    cons_vec = typeof(output.solution)(undef, model.cache.n)
    NLPModels.cons!(model, output.solution, cons_vec)

    grad_vec = typeof(output.solution)(undef, length(output.solution))
    fill!(grad_vec, 0.0)
    NLPModels.grad!(model, output.solution, grad_vec)
    Jtv = similar(grad_vec)
    NLPModels.jtprod!(model, output.solution, output.multipliers, Jtv)
    grad_vec .+= Jtv

    diagnostics.normed_constraint_value = norm(cons_vec)
    diagnostics.normed_grad_value = norm(grad_vec)
end
