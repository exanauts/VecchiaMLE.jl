"""
    diagnostics, result = VecchiaMLE_Run(iVecchiaMLE::VecchiaMLEInput)

    Main function to run the analysis. Make sure that your VecchiaMLEInput struct is 
    filled out correctly!

## Input arguments
* `iVecchiaMLE`: The filled out VecchiaMLEInput struct. See VecchiaMLEInput struct for more details.

## Output arguments
* `diagnostics`: Some diagnostics of the analysis that would be difficult otherwise to get. See Diagnostics struct for more details.
* `pres_chol`: The approximate precision's cholesky, generated by the samples. 
"""
function VecchiaMLE_Run(iVecchiaMLE::VecchiaMLEInput; ptGrid::T=nothing) where T <: Union{AbstractVector, Nothing}

    ptGrid = sanitize_input!(iVecchiaMLE, ptGrid)

    pres_chol = Matrix{eltype(iVecchiaMLE.samples)}(undef, iVecchiaMLE.n^2, iVecchiaMLE.n^2)
    fill!(pres_chol, zero(eltype(iVecchiaMLE.samples)))
    diagnostics = Diagnostics(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0)
    VecchiaMLE_Run_Analysis!(iVecchiaMLE, ptGrid, pres_chol, diagnostics)
    
    return diagnostics, pres_chol
end

"""
See VecchiaMLE_Run().
"""
function VecchiaMLE_Run_Analysis!(iVecchiaMLE::VecchiaMLEInput, ptGrid::AbstractVector, pres_chol::AbstractMatrix, diagnostics::Diagnostics)
    model, output = ExecuteModel!(iVecchiaMLE, ptGrid, pres_chol, diagnostics)

    diagnostics.LinAlg_solve_time = output.counters.linear_solver_time
    diagnostics.MadNLP_iterations = output.iter
    diagnostics.mode = iVecchiaMLE.mode

    # Getting some values for error checking
    diagnostics.objective_value = NLPModels.obj(model, output.solution)
    cons_vec = typeof(output.solution)(undef, model.cache.n)
    NLPModels.cons!(model, output.solution, cons_vec)

    grad_vec = typeof(output.solution)(undef, length(output.solution))
    fill!(grad_vec, 0.0)
    NLPModels.grad!(model, output.solution, grad_vec)
    Jtv = similar(grad_vec)
    NLPModels.jtprod!(model, output.solution, output.multipliers, Jtv)
    grad_vec .+= Jtv

    diagnostics.normed_constraint_value = norm(cons_vec)
    diagnostics.normed_grad_value = norm(grad_vec)
end

"""
See VecchiaMLE_Run().
"""
function ExecuteModel!(iVecchiaMLE::VecchiaMLEInput, ptGrid::AbstractVector, pres_chol::AbstractMatrix, diags::Diagnostics)
    diags.create_model_time = @elapsed begin
        model = get_vecchia_model(iVecchiaMLE, ptGrid)
    end
    
    diags.solve_model_time = @elapsed begin
        output = madnlp(model, print_level=MadNLP_Print_Level(iVecchiaMLE.MadNLP_print_level))
    end
    
    
    # Casting to CPU matrices
    valsL = Vector{Float64}(output.solution[1:model.cache.nnzL])
    rowsL = Vector{Int}(model.cache.rowsL)
    colsL = Vector{Int}(model.cache.colsL)
    copyto!(pres_chol, LowerTriangular(sparse(rowsL, colsL, valsL)))
    return model, output
end
